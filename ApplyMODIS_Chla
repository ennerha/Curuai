# ============================================================
# CURUAI (MODIS SR) — Aplicação do modelo (todos os anos)
# One-shot por mês (sem tiles) + recorte exato pelo shapefile
# - CRS único EPSG:4326 @ 500 m
# - COMPOSITE: "median" (padrão) ou "mean"
# - Inversão ln1p -> expm1
# - Prévia PNG e quantis por mês
# - Aplicando SOMENTE o melhor modelo: SVR_Optuna [Global]
#   (/content/artifacts_curuai/curuai_svr_global.pkl)
# ============================================================

# !pip -q install earthengine-api rasterio joblib numpy pandas matplotlib geopandas shapely fiona pyproj requests tqdm

import os, io, zipfile, warnings, requests, logging, importlib, sys, subprocess
from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def _ensure(pkg, import_name=None):
    name = import_name or pkg.split('==')[0].split('>=')[0]
    try: importlib.import_module(name)
    except ModuleNotFoundError: subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", pkg])

for pkg, imp in [
    ("earthengine-api>=1.0.0","ee"),
    ("rasterio>=1.3.9","rasterio"),
    ("joblib>=1.2","joblib"),
    ("geopandas>=0.14","geopandas"),
    ("shapely>=2.0","shapely"),
    ("fiona>=1.9","fiona"),
    ("pyproj>=3.5","pyproj"),
    ("requests>=2.31","requests"),
    ("tqdm>=4.66","tqdm"),
]:
    _ensure(pkg, imp)

import ee
import rasterio as rio
from rasterio.warp import transform_geom
from rasterio.plot import plotting_extent
from rasterio.features import rasterize
import joblib
import geopandas as gpd
import fiona
from shapely.geometry import mapping
from tqdm import tqdm

warnings.filterwarnings("ignore")
os.environ.setdefault("CPL_DEBUG", "OFF")
os.environ.setdefault("SHAPE_RESTORE_SHX", "YES")

# ---------------- Config ----------------
EE_PROJECT         = os.environ.get("EE_PROJECT", "ee-enneralcantarabariri")

SHP_PATH           = "/content/Curuai.shp"
ROI_CRS_OVERRIDE   = None

ART       = Path("/content/artifacts_curuai_modis_only"); ART.mkdir(parents=True, exist_ok=True)
DIR_FEATS = ART / "features"; DIR_FEATS.mkdir(exist_ok=True, parents=True)
DIR_PRED  = ART / "pred";     DIR_PRED.mkdir(exist_ok=True, parents=True)
PLOT_DIR  = ART / "plots";    PLOT_DIR.mkdir(exist_ok=True, parents=True)

START_YEAR = 2001
END_YEAR   = 2024
MONTHS_FILTER = None          # ex.: [3,6,9,12] para testar só equinócios/solstícios

COMPOSITE            = "median"   # "median" ou "mean"
MASK_STRATEGY        = "loose"    # "strict" | "moderate" | "loose"
FORCE_UNMASK_IN_LOOSE= True

TARGET_CRS   = "EPSG:4326"
TARGET_SCALE = 500                 # metros

# >>> SOMENTE ESTE MODELO será aplicado <<<
P_SVR_GLOB  = "/content/artifacts_curuai/curuai_svr_global.pkl"  # SVR_Optuna [Global]
PRED_INVERSE = "ln1p"              # treino em log1p → aplicar expm1

MAX_PIXELS     = 1e13
EE_TILE_SCALE  = 4
MAX_ERROR_M    = 100
NODATA_PRED    = -9999.0
VERBOSE        = True

# Bandas SR do MOD09GA/MYD09GA (500 m)
SR_BANDS     = ["sur_refl_b01","sur_refl_b02","sur_refl_b03","sur_refl_b04","sur_refl_b05","sur_refl_b06","sur_refl_b07"]
QA_BAND_1KM  = "state_1km"
QA_BAND_500M = "sur_refl_qc_500m"

def log(msg): 
    if VERBOSE: print(msg)

# ---------------- EE init ----------------
def init_ee():
    try:
        ee.Initialize(project=EE_PROJECT)
        log(f"[EE] OK com project: {EE_PROJECT}")
        return
    except Exception:
        pass
    ee.Authenticate(auth_mode='notebook'); ee.Initialize(project=EE_PROJECT); log(f"[EE] OK (auth flow) {EE_PROJECT}")

init_ee()

# ---------------- ROI do shapefile (fix topo) ----------------
def load_roi_gdf(shp_path=SHP_PATH, override_crs=ROI_CRS_OVERRIDE):
    with fiona.Env(SHAPE_RESTORE_SHX='YES'):
        gdf = gpd.read_file(shp_path)
    if override_crs is not None:
        gdf = gdf.set_crs(override_crs, allow_override=True)
    if gdf.crs is None:
        gdf = gdf.set_crs("EPSG:4326")
    # conserta topologia e dissolve em um único polígono
    gdf["geometry"] = gdf.buffer(0)
    gdf = gdf[~gdf.geometry.is_empty]
    uni = gdf.unary_union
    gdf_diss = gpd.GeoDataFrame(geometry=[uni], crs=gdf.crs)
    return gdf_diss

ROI_GDF = load_roi_gdf()
if ROI_GDF.crs.to_string().upper() != "EPSG:4326":
    ROI_GDF = ROI_GDF.to_crs("EPSG:4326")
ROI_UNI = ROI_GDF.geometry.iloc[0]
ROI_EE  = ee.Geometry(mapping(ROI_UNI))
ROI_BOUNDS = ROI_EE.bounds(MAX_ERROR_M).coordinates().getInfo()[0]
xs = [c[0] for c in ROI_BOUNDS]; ys = [c[1] for c in ROI_BOUNDS]
log(f"[ROI] Bounds EPSG:4326: [{min(xs):.6f}, {min(ys):.6f}, {max(xs):.6f}, {max(ys):.6f}]")

# ---------------- Coleções MODIS ----------------
def cloud_shadow_mask(img):
    cond = img.bandNames().contains(QA_BAND_1KM)
    return ee.Image(ee.Algorithms.If(
        cond,
        img.updateMask(
            img.select(QA_BAND_1KM).bitwiseAnd(3).neq(0)
              .Or(img.select(QA_BAND_1KM).bitwiseAnd(1<<2).gt(0))
              .Not()
        ),
        img
    ))

def qc_modland_good(img):
    cond = img.bandNames().contains(QA_BAND_500M)
    return ee.Image(ee.Algorithms.If(
        cond, img.updateMask(img.select(QA_BAND_500M).bitwiseAnd(3).lte(1)), img
    ))

def scale_sr(img):
    scaled = img.select(SR_BANDS).multiply(0.0001).rename(SR_BANDS)
    qa1 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_1KM),  img.select(QA_BAND_1KM),  ee.Image(0).rename(QA_BAND_1KM)))
    qa2 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_500M), img.select(QA_BAND_500M), ee.Image(0).rename(QA_BAND_500M)))
    return scaled.addBands([qa1, qa2]).copyProperties(img, img.propertyNames())

def clear_scaled_masks(img):
    sr  = img.select(SR_BANDS).unmask(0).updateMask(ee.Image(1))
    qa1 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_1KM),  img.select(QA_BAND_1KM),  ee.Image(0).rename(QA_BAND_1KM)))
    qa2 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_500M), img.select(QA_BAND_500M), ee.Image(0).rename(QA_BAND_500M)))
    return sr.addBands([qa1, qa2]).copyProperties(img, img.propertyNames())

def build_collection(start, end):
    mod = ee.ImageCollection("MODIS/061/MOD09GA").filterDate(start, end)
    myd = ee.ImageCollection("MODIS/061/MYD09GA").filterDate(start, end)
    ic  = mod.merge(myd).filterBounds(ROI_EE)
    if MASK_STRATEGY == "strict":
        ic = ic.map(cloud_shadow_mask).map(qc_modland_good)
    elif MASK_STRATEGY == "moderate":
        ic = ic.map(qc_modland_good)
    elif MASK_STRATEGY == "loose":
        pass
    else:
        ic = ic.map(qc_modland_good)
    ic = ic.map(scale_sr)
    if MASK_STRATEGY == "loose" and FORCE_UNMASK_IN_LOOSE:
        ic = ic.map(clear_scaled_masks)
    return ic

def make_mosaic(ic):
    if COMPOSITE == "mean":
        mos = ic.select(SR_BANDS).mean()
    else:
        mos = ic.select(SR_BANDS).median()
    return mos.clip(ROI_EE).reproject(TARGET_CRS, None, TARGET_SCALE)

# ---------------- Features a partir do mosaico ----------------
# Proxies para nomes "Rrs_*" esperados pelo modelo
MODIS_TO_RRS = {
    "Rrs_443": "sur_refl_b03",  # 459–479 (proxy de 443/490)
    "Rrs_490": "sur_refl_b03",
    "Rrs_510": "sur_refl_b04",  # 545–565
    "Rrs_560": "sur_refl_b04",
    "Rrs_620": "sur_refl_b01",  # 620–670
    "Rrs_665": "sur_refl_b01",
}

def build_features_image(mosaic, feature_names):
    """
    Gera APENAS as features pedidas em 'feature_names'.
    Mantém comportamento atual e adiciona:
      - Rrs_709 virtual (extrap. de b04->b01)
      - Rrs_681 / Rrs_700 / Rrs_705 / Rrs_708 VIRTUAIS (interp. entre 665 e 709 virtual)
      - NDCI (709v e 665)
      - Red_a (com 681v e 665; fallback 0)
      - RedEdgeSlope (preferência: 709v - 681v; fallback: 709v - 665)
      - Slope_681_705 (705v - 681v)
      - RedPeakMinusR (700v - 665)
      - *_norm547 (se aparecer), derivadas d1/d2, áreas
    """
    base = {b: mosaic.select(b) for b in SR_BANDS}
    proxies = {k: base[v] for k, v in MODIS_TO_RRS.items() if v in base}

    def safe_div(a,b): return a.divide(b.add(1e-12))
    def safe_ratio(a,b): return a.subtract(b).divide(a.add(b).add(1e-12))
    def safe_add(lst):
        if not lst: return None
        out = lst[0]
        for im in lst[1:]: out = out.add(im)
        return out
    def sum_bands(lst):
        s = safe_add(lst)
        return s.add(1e-12) if s is not None else None

    L1 = sum_bands([base[b] for b in SR_BANDS])

    # --- 709 virtual (fallback simples) ---
    Rrs_709 = None
    if all(b in base for b in ("sur_refl_b01","sur_refl_b04")):
        lam1, lam2, lamT = 560.0, 665.0, 709.0
        slope = base["sur_refl_b01"].subtract(base["sur_refl_b04"]).divide((lam2 - lam1) + 1e-12)
        Rrs_709 = base["sur_refl_b04"].add(slope.multiply(lamT - lam1)).max(0)

    # --- virtuais 681/700/705/708 por interpolação entre 665 (b01) e 709 virtual ---
    def lerp_665_to_709(lambda_nm):
        if (Rrs_709 is None) or ("sur_refl_b01" not in base): 
            return None
        t = (lambda_nm - 665.0) / (709.0 - 665.0)
        return base["sur_refl_b01"].add( Rrs_709.subtract(base["sur_refl_b01"]).multiply(t) ).max(0)

    Rrs_681 = lerp_665_to_709(681.0)
    Rrs_700 = lerp_665_to_709(700.0)
    Rrs_705 = lerp_665_to_709(705.0)
    Rrs_708 = lerp_665_to_709(708.0)

    def norm_by_547(img):
        return img.divide(base["sur_refl_b04"].add(1e-12)) if "sur_refl_b04" in base else None

    # Derivadas (b03, b04, b01, +709v)
    band_name_to_nm = {
        "sur_refl_b03": 470, "sur_refl_b04": 555, "sur_refl_b01": 650, "Rrs_709": 709
    }
    bands_for_deriv = []
    for b in ["sur_refl_b03","sur_refl_b04","sur_refl_b01"]:
        if b in base: bands_for_deriv.append((band_name_to_nm[b], base[b]))
    if Rrs_709 is not None:
        bands_for_deriv.append((709, Rrs_709))
    bands_for_deriv = sorted(bands_for_deriv, key=lambda t: t[0])

    def deriv_stats(img_list):
        if len(img_list) < 3: 
            return None, None, None, None
        stack = ee.Image.cat([im for _, im in img_list])
        d1_list = []
        for i in range(1, len(img_list)):
            d1_list.append(stack.select(i).subtract(stack.select(i-1)))
        d1 = ee.Image.cat(d1_list)
        d1_mean = d1.reduce(ee.Reducer.mean())
        d1_p95  = d1.reduce(ee.Reducer.percentile([95])).rename(d1_mean.bandNames())
        if len(d1_list) < 2:
            return d1_mean, d1_p95, None, None
        d2_list = []
        for i in range(1, len(d1_list)):
            d2_list.append(d1_list[i].subtract(d1_list[i-1]))
        d2 = ee.Image.cat(d2_list)
        d2_mean = d2.reduce(ee.Reducer.mean())
        d2_p95  = d2.reduce(ee.Reducer.percentile([95])).rename(d2_mean.bandNames())
        return d1_mean, d1_p95, d2_mean, d2_p95

    d1_mean_img, d1_p95_img, d2_mean_img, d2_p95_img = deriv_stats(bands_for_deriv)

    bands = []
    for fname in feature_names:
        img = None

        # Rrs_* diretos (proxies) e Rrs_* virtuais
        if fname in proxies:
            img = proxies[fname].rename(fname)
        elif fname == "Rrs_709" and (Rrs_709 is not None):
            img = Rrs_709.rename(fname)
        elif fname == "Rrs_681" and (Rrs_681 is not None):
            img = Rrs_681.rename(fname)
        elif fname == "Rrs_700" and (Rrs_700 is not None):
            img = Rrs_700.rename(fname)
        elif fname == "Rrs_705" and (Rrs_705 is not None):
            img = Rrs_705.rename(fname)
        elif fname == "Rrs_708" and (Rrs_708 is not None):
            img = Rrs_708.rename(fname)

        # normalizações
        elif fname.endswith("_norm560"):
            stem = fname.replace("_norm560","")
            base_img = None
            if stem in proxies: base_img = proxies[stem]
            elif stem == "Rrs_681": base_img = Rrs_681
            elif stem == "Rrs_700": base_img = Rrs_700
            elif stem == "Rrs_705": base_img = Rrs_705
            elif stem == "Rrs_709": base_img = Rrs_709
            elif stem == "Rrs_708": base_img = Rrs_708
            if (base_img is not None) and ("Rrs_560" in proxies):
                img = safe_div(base_img, proxies["Rrs_560"]).rename(fname)

        elif fname.endswith("_norm547"):
            stem = fname.replace("_norm547","")
            base_img = None
            if stem in proxies: base_img = proxies[stem]
            elif stem == "Rrs_681": base_img = Rrs_681
            elif stem == "Rrs_700": base_img = Rrs_700
            elif stem == "Rrs_705": base_img = Rrs_705
            elif stem == "Rrs_709": base_img = Rrs_709
            elif stem == "Rrs_708": base_img = Rrs_708
            if (base_img is not None) and ("sur_refl_b04" in base):
                tmp = norm_by_547(base_img)
                if tmp is not None: img = tmp.rename(fname)

        elif fname == "norm_Rrs_L1" and L1 is not None:
            img = L1.rename(fname)
        elif fname.endswith("_normL1") and L1 is not None:
            stem = fname.replace("_normL1","")
            base_img = None
            if stem in proxies: base_img = proxies[stem]
            elif stem == "Rrs_681": base_img = Rrs_681
            elif stem == "Rrs_700": base_img = Rrs_700
            elif stem == "Rrs_705": base_img = Rrs_705
            elif stem == "Rrs_709": base_img = Rrs_709
            elif stem == "Rrs_708": base_img = Rrs_708
            if base_img is not None:
                img = safe_div(base_img, L1).rename(fname)

        # índices
        elif fname == "G_over_B" and all(b in base for b in ("sur_refl_b04","sur_refl_b03")):
            img = safe_div(base["sur_refl_b04"], base["sur_refl_b03"]).rename(fname)
        elif fname == "B_over_R" and all(b in base for b in ("sur_refl_b03","sur_refl_b01")):
            img = safe_div(base["sur_refl_b03"], base["sur_refl_b01"]).rename(fname)
        elif fname == "NDCI" and (Rrs_709 is not None) and ("sur_refl_b01" in base):
            num = Rrs_709.subtract(base["sur_refl_b01"])
            den = Rrs_709.add(base["sur_refl_b01"]).add(1e-12)
            img = num.divide(den).rename(fname)
        elif fname == "Red_a":
            if (Rrs_681 is not None) and ("sur_refl_b01" in base):
                img = safe_ratio(Rrs_681, base["sur_refl_b01"]).rename(fname)
            else:
                img = ee.Image(0).rename(fname)
        elif fname == "RedEdgeSlope":
            if (Rrs_709 is not None) and (Rrs_681 is not None):
                img = Rrs_709.subtract(Rrs_681).rename(fname)
            elif (Rrs_709 is not None) and ("sur_refl_b01" in base):
                img = Rrs_709.subtract(base["sur_refl_b01"]).rename(fname)

        # métricas solicitadas no warn
        elif fname == "Slope_681_705" and (Rrs_681 is not None) and (Rrs_705 is not None):
            img = Rrs_705.subtract(Rrs_681).rename(fname)
        elif fname == "RedPeakMinusR" and (Rrs_700 is not None) and ("sur_refl_b01" in base):
            img = Rrs_700.subtract(base["sur_refl_b01"]).rename(fname)

        # áreas
        elif fname == "Area_Blue":
            comp = sum_bands([base[b] for b in ["sur_refl_b03"] if b in base])
            if comp is not None: img = comp.rename(fname)
        elif fname == "Area_Green":
            comp = sum_bands([base[b] for b in ["sur_refl_b04"] if b in base])
            if comp is not None: img = comp.rename(fname)
        elif fname == "Area_Red":
            comp = sum_bands([base[b] for b in ["sur_refl_b01"] if b in base])
            if comp is not None: img = comp.rename(fname)
        elif fname == "Area_RE" and (Rrs_709 is not None):
            img = Rrs_709.rename(fname)

        # derivadas
        elif fname == "d1_mean" and (d1_mean_img is not None):
            img = d1_mean_img.rename(fname)
        elif fname == "d1_p95" and (d1_p95_img is not None):
            img = d1_p95_img.rename(fname)
        elif fname == "d2_mean" and (d2_mean_img is not None):
            img = d2_mean_img.rename(fname)
        elif fname == "d2_p95" and (d2_p95_img is not None):
            img = d2_p95_img.rename(fname)

        # fallback: banda constante 0 (não quebra)
        if img is None:
            img = ee.Image(0).rename(fname)

        bands.append(img)

    return ee.Image.cat(bands).reproject(TARGET_CRS, None, TARGET_SCALE)

# ---------------- Export one-shot ----------------
def export_image_to_tif(img, out_path, region=ROI_EE, scale=TARGET_SCALE, crs=TARGET_CRS):
    params = {'scale': scale, 'region': region, 'maxPixels': MAX_PIXELS, 'format': 'GEO_TIFF', 'crs': crs}
    url = img.getDownloadURL(params)
    r = requests.get(url, timeout=600, allow_redirects=True)
    r.raise_for_status()
    data = r.content
    if data[:2] == b'PK':
        with zipfile.ZipFile(io.BytesIO(data)) as zf:
            names = [n for n in zf.namelist() if n.lower().endswith(('.tif','.tiff'))]
            with zf.open(names[0]) as zt, open(out_path, 'wb') as f: f.write(zt.read())
    else:
        with open(out_path, 'wb') as f: f.write(data)

# ---------------- Máscara do shapefile no raster ----------------
def roi_mask_array_like(dataset):
    gdf = ROI_GDF
    src_crs = gdf.crs
    dst_crs = dataset.crs
    geoms_tx = [transform_geom(src_crs.to_string(), dst_crs.to_string(), mapping(g), precision=6)
                for g in gdf.geometry]
    mask = rasterize([(g,1) for g in geoms_tx],
                     out_shape=(dataset.height, dataset.width),
                     transform=dataset.transform,
                     fill=0, all_touched=True, dtype="uint8").astype(bool)
    return mask

# ---------------- Modelo (SOMENTE SVR GLOBAL) ----------------
def load_model():
    if Path(P_SVR_GLOB).exists():
        M = joblib.load(P_SVR_GLOB)
        return "svr", M, M["features"]
    raise RuntimeError("Modelo SVR global não encontrado em: " + P_SVR_GLOB)

def inverse_transform(y):
    if PRED_INVERSE == "ln1p":
        return np.expm1(y)
    elif PRED_INVERSE == "log10_1p":
        return (10.0**y) - 1.0
    else:
        return y

# ---------------- Predição ----------------
def predict_from_features_tif(tif_path, model_kind, M, nodata_out=NODATA_PRED):
    with rio.open(tif_path) as ds:
        arr = ds.read()                   # (B,H,W)
        prof = ds.profile
        roi_mask = roi_mask_array_like(ds)
        valid_mask = np.ones((arr.shape[1], arr.shape[2]), dtype=bool)
        for i in range(arr.shape[0]):
            valid_mask &= (ds.read_masks(i+1) > 0)
        valid_mask &= roi_mask

    B, H, W = arr.shape
    data  = arr.reshape(B, -1).T.astype("float32")
    y_log = np.full(data.shape[0], np.nan, dtype="float32")
    valid = valid_mask.reshape(-1)

    if valid.any():
        X = data[valid]
        finite = np.isfinite(X).all(axis=1)
        if finite.any():
            Xc  = X[finite]
            idx = np.where(valid)[0][finite]
            y_log[idx] = M["model"].predict(Xc).astype("float32")

    y_lin = inverse_transform(y_log.astype("float64"))
    pred  = y_lin.reshape(H, W).astype("float32")
    pred[~valid_mask] = nodata_out
    pred[~np.isfinite(pred)] = nodata_out

    prof_out = prof.copy()
    prof_out.update(dtype="float32", count=1, nodata=nodata_out, compress="deflate")
    out_path = str(tif_path).replace("features/curuai_feats_", "pred/curuai_chla_")
    with rio.open(out_path, "w", **prof_out) as dst: dst.write(pred, 1)
    return out_path

# ---------------- Preview e quantis ----------------
def preview_png(tif_path, title=None):
    with rio.open(tif_path) as ds:
        arr = ds.read(1, masked=True)
        ext = plotting_extent(ds)
        crs = ds.crs
    try:
        gdf = ROI_GDF.to_crs(crs)
    except Exception:
        gdf = None
    v = arr.compressed()
    if v.size:
        vmin, vmax = np.percentile(v, (2,98))
    else:
        vmin, vmax = 0, 1
    plt.figure(figsize=(7,6))
    plt.imshow(arr, extent=ext, vmin=vmin, vmax=vmax, cmap="viridis", interpolation="nearest")
    if gdf is not None: gdf.boundary.plot(ax=plt.gca(), linewidth=1.1, edgecolor="black")
    plt.title(title or Path(tif_path).name); plt.xticks([]); plt.yticks([]); plt.tight_layout()
    out = PLOT_DIR / f"preview_{Path(tif_path).stem}.png"
    plt.savefig(out, dpi=160, bbox_inches="tight"); plt.close()
    log(f"[PREVIEW] {out}")

def print_quantiles(tif_path):
    with rio.open(tif_path) as ds:
        a = ds.read(1)
        m = (a != NODATA_PRED) & np.isfinite(a)
        v = a[m]
    if v.size:
        q = np.percentile(v, [5,25,50,75,90,95,99])
        log(f"[Q] 5%={q[0]:.1f} 25%={q[1]:.1f} 50%={q[2]:.1f} 75%={q[3]:.1f} 90%={q[4]:.1f} 95%={q[5]:.1f} 99%={q[6]:.1f} µg/L")
    else:
        log("[Q] sem dados válidos")

# ---------------- Main ----------------
def main():
    model_kind, M, FEATURE_LIST = load_model()
    log(f"[MODEL] tipo={model_kind} (SVR_Optuna [Global]) | #features={len(FEATURE_LIST)} | EE Project: {EE_PROJECT}")
    log(f"[MODEL] caminho: {P_SVR_GLOB}")
    log(f"[MODEL] primeiras features ({min(10, len(FEATURE_LIST))}): {FEATURE_LIST[:10]}")

    # Checagem leve de compatibilidade (apenas log; não quebra o fluxo)
    GEN_CAPS = {
        "Rrs_443","Rrs_490","Rrs_510","Rrs_560","Rrs_620","Rrs_665",
        "Rrs_681","Rrs_700","Rrs_705","Rrs_708","Rrs_709",
        "norm_Rrs_L1","G_over_B","B_over_R","Red_a","NDCI","RedEdgeSlope",
        "Area_Blue","Area_Green","Area_Red","Area_RE",
        "Slope_681_705","RedPeakMinusR",
        "d1_mean","d1_p95","d2_mean","d2_p95"
    }
    SUPPORTS_SUFFIX = ("_norm560","_norm547","_normL1")
    def _is_supported(fname):
        if fname in GEN_CAPS: return True
        if fname.endswith(SUPPORTS_SUFFIX): return True
        return False
    missing = [f for f in FEATURE_LIST if not _is_supported(f)]
    if missing:
        log("[WARN] Algumas features do modelo não têm geração explícita para MOD09GA; serão preenchidas com 0:")
        for f in missing[:25]: log("   - " + f)

    months = MONTHS_FILTER if MONTHS_FILTER else list(range(1,13))

    for year in range(START_YEAR, END_YEAR+1):
        for month in months:
            ym = f"{year:04d}-{month:02d}"
            feats_tif = DIR_FEATS / f"curuai_feats_{ym}.tif"
            pred_tif  = DIR_PRED  / f"curuai_chla_{ym}.tif"

            try:
                start = ee.Date.fromYMD(year, month, 1); end = start.advance(1, "month")
                ic    = build_collection(start, end)
                n = int(ic.size().getInfo())
                log(f"[{ym}] imagens MODIS: {n}")
                if n == 0:
                    log(f"[{ym}] sem imagens — pulando"); continue

                mosaic   = make_mosaic(ic)
                feats_im = build_features_image(mosaic, FEATURE_LIST)

                log(f"[{ym}] exportando features...")
                export_image_to_tif(feats_im, str(feats_tif), region=ROI_EE, scale=TARGET_SCALE, crs=TARGET_CRS)
                log(f"[export] {feats_tif}")

                log(f"[{ym}] predizendo (SVR)...")
                pred_path = predict_from_features_tif(str(feats_tif), model_kind, M)
                log(f"[pred]   {pred_path}")

                preview_png(pred_path, title=f"Chl-a predito {ym}")
                print_quantiles(pred_path)

            except Exception as e:
                log(f"[{ym}] ERRO: {e}")

    log(f"\n[OK] Processamento concluído. Saídas em: {ART}")

if __name__ == "__main__":
    main()
