# ============================================================
# Curuai | Infer√™ncia MODIS (MOD09GA) -> Chl-a (mg/m¬≥)
# - Escala MODIS 0.0001 aplicada antes das features
# - Features compat√≠veis com treino (ordem = top_features do pkl)
# - Modelo two-stage (classifier + low/high regressor)
# - Exporta rasters mensais j√° em mg/m¬≥ + s√©rie temporal CSV
# ============================================================

# !pip -q install earthengine-api rasterio shapely geopandas tqdm joblib

import os, re, json, math, glob, warnings, tempfile
from pathlib import Path
import numpy as np, pandas as pd
import rasterio as rio
from rasterio.merge import merge as rio_merge
import matplotlib.pyplot as plt
from tqdm import tqdm
import joblib
import ee

warnings.filterwarnings("ignore")

# ----------------------------
# CONFIG
# ----------------------------
EE_PROJECT = "ee-enneralcantarabariri"  # seu projeto EE
OUTROOT    = Path("/content/artifacts_curuai_modis_only")  # raiz de sa√≠da
FEAT_DIR   = OUTROOT / "features"; FEAT_DIR.mkdir(parents=True, exist_ok=True)
PRED_TDIR  = OUTROOT / "pred_tiles"; PRED_TDIR.mkdir(parents=True, exist_ok=True)
PRED_DIR   = OUTROOT / "pred"; PRED_DIR.mkdir(parents=True, exist_ok=True)

MODEL_PATH = Path("/content/artifacts_curuai/curuai_two_stage.pkl")  # gerado no treino
# per√≠odo
START_YM, END_YM = "2013-01", "2024-12"
# ROI (ret√¢ngulo simples como no seu log)
ROI_BOUNDS = [-56.4, -2.55, -56.05, -2.25]  # [minlon, minlat, maxlon, maxlat]
# grade de tiles
TILES_NX, TILES_NY = 4, 4
# resolu√ß√£o e CRS
SCALE = 250  # m (MODIS 250/500 m; estamos usando 250 m)
CRS   = "EPSG:4326"

# ----------------------------
# EARTH ENGINE ‚Äì init
# ----------------------------
try:
    ee.Initialize(project=EE_PROJECT)
except Exception:
    ee.Authenticate()
    ee.Initialize(project=EE_PROJECT)
print("EE ok:", EE_PROJECT)

# ----------------------------
# Helpers de data e ROI
# ----------------------------
def months_between(start_ym: str, end_ym: str):
    ys, ms = map(int, start_ym.split("-"))
    ye, me = map(int, end_ym.split("-"))
    cur_y, cur_m = ys, ms
    out = []
    while (cur_y < ye) or (cur_y == ye and cur_m <= me):
        out.append(f"{cur_y:04d}-{cur_m:02d}")
        cur_m += 1
        if cur_m == 13:
            cur_m = 1; cur_y += 1
    return out

def ym_to_dates(ym: str):
    y, m = map(int, ym.split("-"))
    if m == 12:
        return f"{y:04d}-{m:02d}-01", f"{y+1:04d}-01-01"
    else:
        return f"{y:04d}-{m:02d}-01", f"{y:04d}-{m+1:02d}-01"

ROI = ee.Geometry.Rectangle(ROI_BOUNDS, proj=CRS, geodesic=False)

# ----------------------------
# MODIS -> Rrs + features (EE)
# ----------------------------
# MOD09GA: sur_refl_b01 (RED ~645nm), b03 (BLUE ~469nm), b04 (GREEN ~555nm)
# Usamos nomes compat√≠veis com o treino:
#   Rrs_665 ‚âà b01(645) | Rrs_490 ‚âà b03(469) | Rrs_560 ‚âà b04(555)
def modis_surface_reflectance(img):
    bands = img.select(['sur_refl_b01','sur_refl_b03','sur_refl_b04']).multiply(0.0001)
    return bands.rename(['Rrs_665','Rrs_490','Rrs_560'])

def add_basic_feats(img):
    R665 = img.select('Rrs_665')
    R490 = img.select('Rrs_490')
    R560 = img.select('Rrs_560')

    normL1 = R665.add(R490).add(R560).add(1e-12).rename("norm_Rrs_L1")

    def norm560(b): 
        return b.divide(R560.add(1e-12))

    feats = [
        R665, R490, R560,
        normL1
    ]
    # *_norm560
    feats += [
        norm560(R665).rename('Rrs_665_norm560'),
        norm560(R490).rename('Rrs_490_norm560'),
        norm560(R560).rename('Rrs_560_norm560')
    ]
    # *_normL1
    feats += [
        R665.divide(normL1).rename('Rrs_665_normL1'),
        R490.divide(normL1).rename('Rrs_490_normL1'),
        R560.divide(normL1).rename('Rrs_560_normL1')
    ]
    # √≠ndices que existem com 490/560/665
    feats += [
        R560.divide(R490.add(1e-12)).rename('G_over_B'),
        R490.divide(R665.add(1e-12)).rename('B_over_R')
    ]
    # √°reas aproximadas
    feats += [
        R490.rename('Area_Blue'),
        R560.rename('Area_Green'),
        R665.rename('Area_Red'),
        ee.Image.constant(0).rename('Area_RE')  # n√£o h√° 700‚Äì710 no MODIS
    ]

    # Derivadas (ordem Rrs_490, Rrs_560, Rrs_665)
    arr = img.select(['Rrs_490','Rrs_560','Rrs_665']).toArray()
    d1 = arr.arraySlice(0,1).subtract(arr.arraySlice(0,0,2))  # diffs nas 2 gaps
    # m√©dia e p95 (de 2 valores) ‚Äì aproximamos p95 com max
    d1_mean = d1.arrayReduce(ee.Reducer.mean(), [0]).arrayGet([0]).rename('d1_mean')
    d1_max  = d1.arrayReduce(ee.Reducer.max(),  [0]).arrayGet([0]).rename('d1_p95')
    # 2¬™ derivada (1 valor)
    d2 = arr.arraySlice(0,2).subtract(arr.arraySlice(0,1)).subtract(
         arr.arraySlice(0,1).subtract(arr.arraySlice(0,0)))  # (b3-b2)-(b2-b1)
    d2_mean = d2.arrayReduce(ee.Reducer.mean(), [0]).arrayGet([0]).rename('d2_mean')
    d2_max  = d2.arrayReduce(ee.Reducer.max(),  [0]).arrayGet([0]).rename('d2_p95')

    feats += [d1_mean, d1_max, d2_mean, d2_max]

    return img.addBands(ee.Image.cat(feats), overwrite=True)

def build_feature_image(ym: str, model_features: list):
    d1, d2 = ym_to_dates(ym)
    col = (ee.ImageCollection('MODIS/006/MOD09GA')
           .filterDate(d1, d2)
           .filterBounds(ROI)
           .map(modis_surface_reflectance)
           .map(add_basic_feats))

    # mosaico robusto (mediana)
    mos = col.median().clip(ROI)

    # cria imagem com as bandas na MESMA ORDEM do modelo
    bands = []
    for name in model_features:
        if mos.bandNames().contains(name).getInfo():
            bands.append(mos.select(name))
        else:
            # feature indispon√≠vel -> constante ~0 (n√£o ideal, mas evita quebra)
            bands.append(ee.Image.constant(0).rename(name))
    feat_img = ee.Image.cat(bands).rename(model_features)
    return feat_img

# ----------------------------
# Export (download) via thumb getPixels
# ----------------------------
def ee_export_tif(img, region, scale, crs, out_path):
    # Usa thumbnail:getPixels (r√°pido e s√≠ncrono para tiles)
    params = {
        'region': region,
        'scale': scale,
        'crs': crs,
        'format': 'GEO_TIFF'
    }
    url = img.getThumbURL(params)
    import requests
    r = requests.get(url, stream=True)
    r.raise_for_status()
    with open(out_path, 'wb') as f:
        for chunk in r.iter_content(chunk_size=1<<20):
            if chunk: f.write(chunk)
    return out_path

# ----------------------------
# Grade de tiles
# ----------------------------
def split_rect(rect: ee.Geometry, nx=4, ny=4):
    coords = rect.bounds().coordinates().get(0).getInfo()
    xs = [c[0] for c in coords[:-1]]
    ys = [c[1] for c in coords[:-1]]
    minx, maxx = min(xs), max(xs); miny, maxy = min(ys), max(ys)
    dx = (maxx - minx)/nx; dy = (maxy - miny)/ny
    tiles = []
    for j in range(ny):
        for i in range(nx):
            x0 = minx + i*dx; x1 = x0 + dx
            y0 = miny + j*dy; y1 = y0 + dy
            tiles.append(ee.Geometry.Rectangle([x0,y0,x1,y1], proj=CRS, geodesic=False))
    return tiles

TILES = split_rect(ROI, TILES_NX, TILES_NY)

# ----------------------------
# Carrega modelo two-stage
# ----------------------------
assert MODEL_PATH.exists(), f"Modelo n√£o encontrado: {MODEL_PATH}"
art = joblib.load(MODEL_PATH)
# padr√£o salvo no seu treino:
# {"classifier": CLS_BEST, "low_regressor": LOW_REG, "high_regressor": HIGH_REG, "features": top_features, ...}
cls = art.get("classifier") or art.get("clf")
reg_low  = art.get("low_regressor")  or art.get("reg_low")
reg_high = art.get("high_regressor") or art.get("reg_high")
model_features = art["features"]
print("‚úì Modelo carregado:", MODEL_PATH)
print("‚úì Features alvo carregadas:", len(model_features))

# ----------------------------
# Predi√ß√£o em tiles (por m√™s) + mosaico e inversa (mg/m¬≥)
# ----------------------------
def raster_to_X(ds: rio.io.DatasetReader):
    arr = ds.read()  # (bands, rows, cols)
    n_b, n_r, n_c = arr.shape
    X = arr.reshape(n_b, n_r*n_c).T  # (N, nb)
    return X, (n_r, n_c)

def predict_two_stage(X):
    # retorna yhat_log (mesmo dom√≠nio do treino)
    # classifica
    pred_class = cls.predict(X).astype(int)
    yhat = np.full(X.shape[0], np.nan, dtype="float64")
    m0 = pred_class == 0
    m1 = ~m0
    if m0.any():
        yhat[m0] = reg_low.predict(X[m0])
    if m1.any():
        yhat[m1] = reg_high.predict(X[m1])
    return yhat

def write_geotiff_like(template_path, out_path, data2d, nodata=np.nan, tags=None):
    with rio.open(template_path) as src:
        prof = src.profile.copy()
        prof.update({
            "count": 1,
            "dtype": "float32",
            "nodata": nodata
        })
        with rio.open(out_path, "w", **prof) as dst:
            dst.write(data2d.astype("float32"), 1)
            if tags:
                dst.update_tags(**tags)

def mosaic_month(ym, tile_tifs, out_dir=PRED_DIR):
    if len(tile_tifs) == 1:
        # nome final
        final = out_dir / f"curuai_chla_{ym}.tif"
        # s√≥ copia com tags
        with rio.open(tile_tifs[0]) as src:
            prof = src.profile
            data = src.read(1)
            with rio.open(final, "w", **prof) as dst:
                dst.write(data, 1)
                dst.update_tags(UNITS="mg m^-3", PRED_DOMAIN="mgm3",
                                COMMENT="Chl-a predita a partir de MODIS (two-stage); esc. 0.0001 aplicada no mosaico.")
        return str(final)

    srcs = [rio.open(p) for p in tile_tifs]
    mosaic_arr, mosaic_trans = rio_merge(srcs)
    for s in srcs: s.close()
    ref = rio.open(tile_tifs[0])
    prof = ref.profile.copy()
    prof.update({"height": mosaic_arr.shape[1], "width": mosaic_arr.shape[2],
                 "transform": mosaic_trans, "count": 1, "dtype": "float32"})
    out_path = out_dir / f"curuai_chla_{ym}.tif"
    with rio.open(out_path, "w", **prof) as dst:
        dst.write(mosaic_arr.astype("float32")[0], 1)
        dst.update_tags(UNITS="mg m^-3", PRED_DOMAIN="mgm3",
                        COMMENT="Chl-a predita a partir de MODIS (two-stage); esc. 0.0001 aplicada no mosaico.")
    ref.close()
    return str(out_path)

# Loop principal
all_months = months_between(START_YM, END_YM)
print(f"\nüöÄ INICIANDO PROCESSAMENTO | Per√≠odo: {START_YM}‚Äì{END_YM}  ROI:{ROI_BOUNDS}")
for ym in tqdm(all_months):
    y1, y2 = ym_to_dates(ym)
    # 1) imagem de features (mesma ORDEM do modelo)
    feat_img = build_feature_image(ym, model_features)

    # 2) export por tiles
    tile_paths = []
    print(f"\n--- {ym} ---")
    # contagem imagens s√≥ pra log
    nimgs = (ee.ImageCollection('MODIS/006/MOD09GA')
             .filterDate(y1, y2).filterBounds(ROI).size().getInfo())
    print(f"  MODIS: {nimgs} imagens (limite {TILES_NX*TILES_NY*5})")
    for tix, tile in enumerate(TILES, start=1):
        tif_path = FEAT_DIR / f"curuai_feats_{ym}_tile{tix}.tif"
        if not tif_path.exists():
            try:
                ee_export_tif(feat_img, tile, SCALE, CRS, str(tif_path))
            except Exception as e:
                print(f"    ‚úó tile {tix} erro export: {e}")
                continue
        print(f"    ‚úì feat tile {tix}/{len(TILES)}")
        tile_paths.append(str(tif_path))

    # 3) predi√ß√£o por tile (inversa aplicada ANTES de escrever)
    pred_tiles = []
    ok_count = 0
    for tix, fpath in enumerate(tile_paths, start=1):
        try:
            with rio.open(fpath) as ds:
                X, (nr, nc) = raster_to_X(ds)
                # NaN/Inf -> 0
                X = np.nan_to_num(X, nan=0.0, posinf=0.0, neginf=0.0)
                yhat_log = predict_two_stage(X)
                yhat = np.expm1(yhat_log)  # ‚Üê inversa (mg/m¬≥)
                yhat[yhat < 0] = 0
                Y = yhat.reshape(nr, nc)
            out_tile = PRED_TDIR / f"curuai_chla_{ym}_tile{tix}.tif"
            write_geotiff_like(fpath, out_tile, Y, nodata=np.nan,
                               tags={"UNITS":"mg m^-3","PRED_DOMAIN":"mgm3",
                                     "COMMENT":"Two-stage; inversa aplicada; fonte: MOD09GA; scale 0.0001 nas Rrs"})
            pred_tiles.append(str(out_tile))
            ok_count += 1
        except Exception as e:
            print(f"    ‚úó erro predict tile {tix}: {e}")
    print(f"  üß† predi√ß√£o por tile  ‚úì {ok_count}/{len(tile_paths)} tiles")

    # 4) mosaico mensal final
    if ok_count > 0:
        final_path = mosaic_month(ym, pred_tiles, out_dir=PRED_DIR)
        print("  üì¶ mosaico:", final_path)
    else:
        print("  ‚ö† sem tiles v√°lidos neste m√™s; pulando mosaico.")

# ----------------------------
# S√©rie temporal (mg/m¬≥) + gr√°fico
# ----------------------------
def ym_from_path(p):
    m = re.search(r"(\d{4})-(\d{2})", os.path.basename(p))
    return f"{m.group(1)}-{m.group(2)}" if m else None

files = sorted(glob.glob(str(PRED_DIR / "curuai_chla_*.tif")))
rows = []
for f in files:
    with rio.open(f) as ds:
        a = ds.read(1, masked=True)
        a = np.ma.masked_invalid(a)
        a = np.ma.masked_less(a, 0)
        if a.count() == 0:
            continue
        rows.append({
            "ym": ym_from_path(f),
            "mean_chla_mg_m3": float(a.mean()),
            "median_chla_mg_m3": float(np.ma.median(a)),
            "p90_chla_mg_m3": float(np.nanpercentile(a.compressed(), 90))
        })

ts = pd.DataFrame(rows).set_index("ym").sort_index()
csv_out = OUTROOT / "summary_timeseries.csv"
ts.to_csv(csv_out, index=True)
print("\nCSV salvo em", csv_out)

# gr√°fico simples
if len(ts):
    plt.figure(figsize=(12,4))
    ts["median_chla_mg_m3"].plot()
    plt.title("Clorofila-a mediana mensal (ROI) ‚Äî mg/m¬≥")
    plt.xlabel("M√™s"); plt.ylabel("Chl-a (mg/m¬≥)")
    plt.grid(True, alpha=.3); plt.tight_layout(); plt.show()
else:
    print("Sem dados para plotar (verifique meses v√°lidos).")
