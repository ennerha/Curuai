# ============================================================
# CURUAI (MODIS SR) — Aplicação do modelo (todos os anos)
# One-shot por mês (sem tiles) + recorte exato pelo shapefile
# - CRS único EPSG:4326 @ 500 m
# - COMPOSITE: "median" (padrão) ou "mean"
# - Inversão ln1p -> expm1
# - Prévia PNG e quantis por mês
# ============================================================

# !pip -q install earthengine-api rasterio joblib numpy pandas matplotlib geopandas shapely fiona pyproj requests tqdm

import os, io, zipfile, warnings, requests, logging, importlib, sys, subprocess
from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def _ensure(pkg, import_name=None):
    name = import_name or pkg.split('==')[0].split('>=')[0]
    try: importlib.import_module(name)
    except ModuleNotFoundError: subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", pkg])

for pkg, imp in [
    ("earthengine-api>=1.0.0","ee"),
    ("rasterio>=1.3.9","rasterio"),
    ("joblib>=1.2","joblib"),
    ("geopandas>=0.14","geopandas"),
    ("shapely>=2.0","shapely"),
    ("fiona>=1.9","fiona"),
    ("pyproj>=3.5","pyproj"),
    ("requests>=2.31","requests"),
    ("tqdm>=4.66","tqdm"),
]:
    _ensure(pkg, imp)

import ee
import rasterio as rio
from rasterio.warp import transform_geom
from rasterio.plot import plotting_extent
from rasterio.features import rasterize
import joblib
import geopandas as gpd
import fiona
from shapely.geometry import mapping
from tqdm import tqdm

warnings.filterwarnings("ignore")
os.environ.setdefault("CPL_DEBUG", "OFF")
os.environ.setdefault("SHAPE_RESTORE_SHX", "YES")

# ---------------- Config ----------------
EE_PROJECT         = os.environ.get("EE_PROJECT", "ee-enneralcantarabariri")

SHP_PATH           = "/content/Curuai.shp"
ROI_CRS_OVERRIDE   = None

ART       = Path("/content/artifacts_curuai_modis_only"); ART.mkdir(parents=True, exist_ok=True)
DIR_FEATS = ART / "features"; DIR_FEATS.mkdir(exist_ok=True, parents=True)
DIR_PRED  = ART / "pred";     DIR_PRED.mkdir(exist_ok=True, parents=True)
PLOT_DIR  = ART / "plots";    PLOT_DIR.mkdir(exist_ok=True, parents=True)

START_YEAR = 2001
END_YEAR   = 2024
MONTHS_FILTER = None          # ex.: [3,6,9,12] para testar só equinócios/solstícios

COMPOSITE            = "median"   # "median" ou "mean"
MASK_STRATEGY        = "loose"    # "strict" | "moderate" | "loose"
FORCE_UNMASK_IN_LOOSE= True

TARGET_CRS   = "EPSG:4326"
TARGET_SCALE = 500                 # metros

P_TWO_STAGE = "/content/artifacts_curuai/curuai_two_stage.pkl"
P_SVR_GLOB  = "/content/artifacts_curuai/curuai_svr_global.pkl"
PRED_INVERSE = "ln1p"              # treino em log1p → aplicar expm1

MAX_PIXELS     = 1e13
EE_TILE_SCALE  = 4
MAX_ERROR_M    = 100
NODATA_PRED    = -9999.0
VERBOSE        = True

SR_BANDS     = ["sur_refl_b01","sur_refl_b02","sur_refl_b03","sur_refl_b04","sur_refl_b05","sur_refl_b06","sur_refl_b07"]
QA_BAND_1KM  = "state_1km"
QA_BAND_500M = "sur_refl_qc_500m"

def log(msg): 
    if VERBOSE: print(msg)

# ---------------- EE init ----------------
def init_ee():
    try:
        ee.Initialize(project=EE_PROJECT)
        log(f"[EE] OK com project: {EE_PROJECT}")
        return
    except Exception:
        pass
    ee.Authenticate(auth_mode='notebook'); ee.Initialize(project=EE_PROJECT); log(f"[EE] OK (auth flow) {EE_PROJECT}")

init_ee()

# ---------------- ROI do shapefile (fix topo) ----------------
def load_roi_gdf(shp_path=SHP_PATH, override_crs=ROI_CRS_OVERRIDE):
    with fiona.Env(SHAPE_RESTORE_SHX='YES'):              # <<< corrigido: usar fiona.Env
        gdf = gpd.read_file(shp_path)
    if override_crs is not None:
        gdf = gdf.set_crs(override_crs, allow_override=True)
    if gdf.crs is None:
        gdf = gdf.set_crs("EPSG:4326")
    # conserta topologia e dissolve em um único polígono
    gdf["geometry"] = gdf.buffer(0)
    gdf = gdf[~gdf.geometry.is_empty]
    uni = gdf.unary_union
    gdf_diss = gpd.GeoDataFrame(geometry=[uni], crs=gdf.crs)
    return gdf_diss

ROI_GDF = load_roi_gdf()
if ROI_GDF.crs.to_string().upper() != "EPSG:4326":
    ROI_GDF = ROI_GDF.to_crs("EPSG:4326")
ROI_UNI = ROI_GDF.geometry.iloc[0]
ROI_EE  = ee.Geometry(mapping(ROI_UNI))
ROI_BOUNDS = ROI_EE.bounds(MAX_ERROR_M).coordinates().getInfo()[0]
xs = [c[0] for c in ROI_BOUNDS]; ys = [c[1] for c in ROI_BOUNDS]
log(f"[ROI] Bounds EPSG:4326: [{min(xs):.6f}, {min(ys):.6f}, {max(xs):.6f}, {max(ys):.6f}]")

# ---------------- Coleções MODIS ----------------
def cloud_shadow_mask(img):
    cond = img.bandNames().contains(QA_BAND_1KM)
    return ee.Image(ee.Algorithms.If(
        cond,
        img.updateMask(
            img.select(QA_BAND_1KM).bitwiseAnd(3).neq(0)
              .Or(img.select(QA_BAND_1KM).bitwiseAnd(1<<2).gt(0))
              .Not()
        ),
        img
    ))

def qc_modland_good(img):
    cond = img.bandNames().contains(QA_BAND_500M)
    return ee.Image(ee.Algorithms.If(
        cond, img.updateMask(img.select(QA_BAND_500M).bitwiseAnd(3).lte(1)), img
    ))

def scale_sr(img):
    scaled = img.select(SR_BANDS).multiply(0.0001).rename(SR_BANDS)
    qa1 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_1KM),  img.select(QA_BAND_1KM),  ee.Image(0).rename(QA_BAND_1KM)))
    qa2 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_500M), img.select(QA_BAND_500M), ee.Image(0).rename(QA_BAND_500M)))
    return scaled.addBands([qa1, qa2]).copyProperties(img, img.propertyNames())

def clear_scaled_masks(img):
    sr  = img.select(SR_BANDS).unmask(0).updateMask(ee.Image(1))
    qa1 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_1KM),  img.select(QA_BAND_1KM),  ee.Image(0).rename(QA_BAND_1KM)))
    qa2 = ee.Image(ee.Algorithms.If(img.bandNames().contains(QA_BAND_500M), img.select(QA_BAND_500M), ee.Image(0).rename(QA_BAND_500M)))
    return sr.addBands([qa1, qa2]).copyProperties(img, img.propertyNames())

def build_collection(start, end):
    mod = ee.ImageCollection("MODIS/061/MOD09GA").filterDate(start, end)
    myd = ee.ImageCollection("MODIS/061/MYD09GA").filterDate(start, end)
    ic  = mod.merge(myd).filterBounds(ROI_EE)
    if MASK_STRATEGY == "strict":
        ic = ic.map(cloud_shadow_mask).map(qc_modland_good)
    elif MASK_STRATEGY == "moderate":
        ic = ic.map(qc_modland_good)
    elif MASK_STRATEGY == "loose":
        pass
    else:
        ic = ic.map(qc_modland_good)
    ic = ic.map(scale_sr)
    if MASK_STRATEGY == "loose" and FORCE_UNMASK_IN_LOOSE:
        ic = ic.map(clear_scaled_masks)
    return ic

def make_mosaic(ic):
    if COMPOSITE == "mean":
        mos = ic.select(SR_BANDS).mean()
    else:
        mos = ic.select(SR_BANDS).median()
    return mos.clip(ROI_EE).reproject(TARGET_CRS, None, TARGET_SCALE)

# ---------------- Features a partir do mosaico ----------------
MODIS_TO_RRS = {
    "Rrs_443": "sur_refl_b03",
    "Rrs_490": "sur_refl_b03",
    "Rrs_510": "sur_refl_b04",
    "Rrs_560": "sur_refl_b04",
    "Rrs_620": "sur_refl_b01",
    "Rrs_665": "sur_refl_b01",
}

def build_features_image(mosaic, feature_names):
    base = {b: mosaic.select(b) for b in SR_BANDS}
    proxies = {k: base[v] for k, v in MODIS_TO_RRS.items()}

    def safe_div(a,b): return a.divide(b.add(1e-12))
    def sum_bands(lst):
        out = lst[0]
        for im in lst[1:]: out = out.add(im)
        return out.add(1e-12)
    L1 = sum_bands([base[b] for b in SR_BANDS])

    bands = []
    for fname in feature_names:
        img = None
        if fname in proxies:
            img = proxies[fname].rename(fname)
        elif fname.endswith("_norm560"):
            stem = fname.replace("_norm560","")
            if (stem in proxies) and ("Rrs_560" in proxies):
                img = safe_div(proxies[stem], proxies["Rrs_560"]).rename(fname)
        elif fname == "norm_Rrs_L1":
            img = L1.rename(fname)
        elif fname.endswith("_normL1"):
            stem = fname.replace("_normL1","")
            if stem in proxies:
                img = safe_div(proxies[stem], L1).rename(fname)
        elif fname == "G_over_B":
            img = safe_div(base["sur_refl_b04"], base["sur_refl_b03"]).rename(fname)
        elif fname == "B_over_R":
            img = safe_div(base["sur_refl_b03"], base["sur_refl_b01"]).rename(fname)
        elif fname == "Red_a":
            img = ee.Image(0).rename(fname)
        if img is None:
            img = ee.Image(0).rename(fname)
        bands.append(img)
    return ee.Image.cat(bands).reproject(TARGET_CRS, None, TARGET_SCALE)

# ---------------- Export one-shot ----------------
def export_image_to_tif(img, out_path, region=ROI_EE, scale=TARGET_SCALE, crs=TARGET_CRS):
    params = {'scale': scale, 'region': region, 'maxPixels': MAX_PIXELS, 'format': 'GEO_TIFF', 'crs': crs}
    url = img.getDownloadURL(params)
    r = requests.get(url, timeout=600, allow_redirects=True)
    r.raise_for_status()
    data = r.content
    if data[:2] == b'PK':
        with zipfile.ZipFile(io.BytesIO(data)) as zf:
            names = [n for n in zf.namelist() if n.lower().endswith(('.tif','.tiff'))]
            with zf.open(names[0]) as zt, open(out_path, 'wb') as f: f.write(zt.read())
    else:
        with open(out_path, 'wb') as f: f.write(data)

# ---------------- Máscara do shapefile no raster ----------------
def roi_mask_array_like(dataset):
    gdf = ROI_GDF
    src_crs = gdf.crs
    dst_crs = dataset.crs
    geoms_tx = [transform_geom(src_crs.to_string(), dst_crs.to_string(), mapping(g), precision=6)
                for g in gdf.geometry]
    mask = rasterize([(g,1) for g in geoms_tx],
                     out_shape=(dataset.height, dataset.width),
                     transform=dataset.transform,
                     fill=0, all_touched=True, dtype="uint8").astype(bool)
    return mask

# ---------------- Modelo ----------------
def load_model():
    if Path(P_TWO_STAGE).exists():
        M = joblib.load(P_TWO_STAGE); return "two", M, M["features"]
    if Path(P_SVR_GLOB).exists():
        M = joblib.load(P_SVR_GLOB);  return "svr", M, M["features"]
    raise RuntimeError("Nenhum modelo encontrado em /content/artifacts_curuai/")

def inverse_transform(y):
    if PRED_INVERSE == "ln1p":
        return np.expm1(y)
    elif PRED_INVERSE == "log10_1p":
        return (10.0**y) - 1.0
    else:
        return y

# ---------------- Predição ----------------
def predict_from_features_tif(tif_path, model_kind, M, nodata_out=NODATA_PRED):
    with rio.open(tif_path) as ds:
        arr = ds.read()                   # (B,H,W)
        prof = ds.profile
        roi_mask = roi_mask_array_like(ds)
        valid_mask = np.ones((arr.shape[1], arr.shape[2]), dtype=bool)
        for i in range(arr.shape[0]):
            valid_mask &= (ds.read_masks(i+1) > 0)
        valid_mask &= roi_mask

    B, H, W = arr.shape
    data  = arr.reshape(B, -1).T.astype("float32")
    y_log = np.full(data.shape[0], np.nan, dtype="float32")
    valid = valid_mask.reshape(-1)

    if valid.any():
        X = data[valid]
        finite = np.isfinite(X).all(axis=1)
        if finite.any():
            Xc  = X[finite]
            idx = np.where(valid)[0][finite]
            if model_kind == "two":
                clf = M["classifier"]; low = M["low_regressor"]; high = M["high_regressor"]
                c = clf.predict(Xc).astype(int)
                yhat = np.empty(Xc.shape[0], dtype="float32")
                m0 = (c == 0); m1 = ~m0
                if m0.any():  yhat[m0] = low.predict(Xc[m0]).astype("float32")
                if m1.any():  yhat[m1] = high.predict(Xc[m1]).astype("float32")
                y_log[idx] = yhat
            else:
                y_log[idx] = M["model"].predict(Xc).astype("float32")

    y_lin = inverse_transform(y_log.astype("float64"))
    pred  = y_lin.reshape(H, W).astype("float32")
    pred[~valid_mask] = nodata_out
    pred[~np.isfinite(pred)] = nodata_out

    prof_out = prof.copy()
    prof_out.update(dtype="float32", count=1, nodata=nodata_out, compress="deflate")
    out_path = str(tif_path).replace("features/curuai_feats_", "pred/curuai_chla_")
    with rio.open(out_path, "w", **prof_out) as dst: dst.write(pred, 1)
    return out_path

# ---------------- Preview e quantis ----------------
def preview_png(tif_path, title=None):
    with rio.open(tif_path) as ds:
        arr = ds.read(1, masked=True)
        ext = plotting_extent(ds)
        crs = ds.crs
    try:
        gdf = ROI_GDF.to_crs(crs)
    except Exception:
        gdf = None
    v = arr.compressed()
    if v.size:
        vmin, vmax = np.percentile(v, (2,98))
    else:
        vmin, vmax = 0, 1
    plt.figure(figsize=(7,6))
    plt.imshow(arr, extent=ext, vmin=vmin, vmax=vmax, cmap="viridis", interpolation="nearest")
    if gdf is not None: gdf.boundary.plot(ax=plt.gca(), linewidth=1.1, edgecolor="black")
    plt.title(title or Path(tif_path).name); plt.xticks([]); plt.yticks([]); plt.tight_layout()
    out = PLOT_DIR / f"preview_{Path(tif_path).stem}.png"
    plt.savefig(out, dpi=160, bbox_inches="tight"); plt.close()
    log(f"[PREVIEW] {out}")

def print_quantiles(tif_path):
    with rio.open(tif_path) as ds:
        a = ds.read(1)
        m = (a != NODATA_PRED) & np.isfinite(a)
        v = a[m]
    if v.size:
        q = np.percentile(v, [5,25,50,75,90,95,99])
        log(f"[Q] 5%={q[0]:.1f} 25%={q[1]:.1f} 50%={q[2]:.1f} 75%={q[3]:.1f} 90%={q[4]:.1f} 95%={q[5]:.1f} 99%={q[6]:.1f} µg/L")
    else:
        log("[Q] sem dados válidos")

# ---------------- Main ----------------
def main():
    model_kind, M, FEATURE_LIST = load_model()
    log(f"[MODEL] tipo={model_kind}  |  #features={len(FEATURE_LIST)}  |  Project EE: {EE_PROJECT}")
    months = MONTHS_FILTER if MONTHS_FILTER else list(range(1,13))

    for year in range(START_YEAR, END_YEAR+1):
        for month in months:
            ym = f"{year:04d}-{month:02d}"
            feats_tif = DIR_FEATS / f"curuai_feats_{ym}.tif"
            pred_tif  = DIR_PRED  / f"curuai_chla_{ym}.tif"

            try:
                start = ee.Date.fromYMD(year, month, 1); end = start.advance(1, "month")
                ic    = build_collection(start, end)
                n = int(ic.size().getInfo())
                log(f"[{ym}] imagens MODIS: {n}")
                if n == 0:
                    log(f"[{ym}] sem imagens — pulando"); continue

                mosaic   = make_mosaic(ic)
                feats_im = build_features_image(mosaic, FEATURE_LIST)

                log(f"[{ym}] exportando features...")
                export_image_to_tif(feats_im, str(feats_tif), region=ROI_EE, scale=TARGET_SCALE, crs=TARGET_CRS)
                log(f"[export] {feats_tif}")

                log(f"[{ym}] predizendo...")
                pred_path = predict_from_features_tif(str(feats_tif), model_kind, M)
                log(f"[pred]   {pred_path}")

                preview_png(pred_path, title=f"Chl-a predito {ym}")
                print_quantiles(pred_path)

            except Exception as e:
                log(f"[{ym}] ERRO: {e}")

    log(f"\n[OK] Processamento concluído. Saídas em: {ART}")

if __name__ == "__main__":
    main()
